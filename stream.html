<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="mobile-web-app-capable" content="yes">
    <title>mapMD</title>
</head>
<script src="pixi.js"></script>
<script src="js/tools/webcam.js"></script>
<script src="js/tools/tools.js"></script>
<script src="js/tools/ColorMapFilter.js"></script>
<script src="js/tools/webcam.js"></script>
<script src="js/tools/animation.js"></script>
<script src="js/tools/tween.js"></script>
<body>
<style>* {
    padding: 0;
    margin: 0;
    height: 100%;

}
</style>
<script type="text/javascript">
    class BarrelFilter extends PIXI.Filter {
        constructor(power = 1.2, offset = { x: 0, y: 0 }) {
            super(undefined, BarrelFilter.fragment);
            this.uniforms.dimensions = { x: 0, y: 0 };
            this.uniforms.filterArea = { x: 0, y: 0, z: 0, w: 0 };
            this.uniforms.power = power;
            this.uniforms.offset = offset;

            this.uniforms.nssm = new PIXI.Matrix();
            this.uniforms.inssm = new PIXI.Matrix();
        }
        apply(filterManager, input, output) {
            this.uniforms.dimensions.x = input.sourceFrame.width;
            this.uniforms.dimensions.y = input.sourceFrame.height;
            this.uniforms.filterArea.x = output.size.width;
            this.uniforms.filterArea.y = output.size.height;
            this.uniforms.filterArea.z = input.sourceFrame.x;
            this.uniforms.filterArea.w = input.sourceFrame.y;

            filterManager.calculateNormalizedScreenSpaceMatrix(this.uniforms.nssm);
            filterManager.calculateNormalizedScreenSpaceMatrix(this.uniforms.inssm);
            this.uniforms.inssm.invert();

            filterManager.applyFilter(this, input, output);
        }
    }
    BarrelFilter.fragment = `
        precision highp float;

        varying vec2 vTextureCoord;
        varying vec2 vFilterCoord;
        uniform sampler2D uSampler;
        uniform vec2 dimensions;
        uniform vec4 filterArea;

        uniform float power;
        uniform vec2 offset;

        uniform mat3 nssm;
        uniform mat3 inssm;

        vec2 mapCoord( vec2 coord ){
            return (vec3(coord, 1.0) * nssm).xy;
        }

        vec2 unmapCoord( vec2 coord ){
            return (vec3(coord, 1.0) * inssm).xy;
        }

        // Given a vec2 in [-1,+1], generate a texture coord in [0,+1]
        vec2 barrelDistortion(vec2 p)
        {
            float theta  = atan(p.y, p.x);
            float radius = length(p);
            radius = pow(radius, power);
            p.x = radius * cos(theta);
            p.y = radius * sin(theta);
            return 0.5 * (p + 1.0);
        }

        void main(){
            vec2 uv = mapCoord(vTextureCoord);
            uv = barrelDistortion(uv*2.0 - 1.0 + offset);
            gl_FragColor = texture2D(uSampler, unmapCoord(uv));
        }
    `;

    class VisionMapFilter extends PIXI.Filter {
        constructor() {
            super(VisionMapFilter.vertexShader, VisionMapFilter.fragmentShader);
            this.uniforms.nssm = new PIXI.Matrix();
            this.uniforms.inssm = new PIXI.Matrix();

            this.uniforms.stage = 0;
        }
        apply(filterManager, input, output) {
            filterManager.calculateNormalizedScreenSpaceMatrix(this.uniforms.nssm);
            filterManager.calculateNormalizedScreenSpaceMatrix(this.uniforms.inssm);
            this.uniforms.inssm.invert();

            filterManager.applyFilter(this, input, output);
        }
    }
    VisionMapFilter.vertexShader = `
            attribute vec2 aVertexPosition;
            attribute vec2 aTextureCoord;
            uniform mat3 projectionMatrix;
            uniform mat3 filterMatrix;
            varying vec2 vTextureCoord;
            varying vec2 vFilterCoord;
            void main(void){
               gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
               vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0) ).xy;
               vTextureCoord = vFilterCoord;
            }
        `;
    VisionMapFilter.fragmentShader = `
            precision highp float;

            varying vec2 vTextureCoord;
            uniform sampler2D uSampler;

            uniform mat3 nssm;
            uniform mat3 inssm;
            uniform float stage;

            vec2 mapCoord( vec2 coord ){
                return (vec3(coord, 1.0) * nssm).xy;
            }

            vec2 unmapCoord( vec2 coord ){
                return (vec3(coord, 1.0) * inssm).xy;
            }

            vec2 warpAround(vec2 uv, vec2 p, float rInner, float rOuter) {
                vec2 d = p - uv;
                float l = length(d);
                vec2 n = normalize(d);
                float r = rInner;
                float R = rOuter;

                // float x = max(R - l, 0.0);
                // float m = pow(x/R, 0.5);
                // float m = smoothstep(0.0, R, x);
                float x = 1.0 - clamp((l - r)/(R - r), 0.0, 1.0);
                float m = x;

                return n * m * l;
            }

            vec3 brightnessContrast(vec3 value, float brightness, float contrast){
                return (value - 0.5) * contrast + 0.5 + brightness;
            }

            vec3 enhance(vec3 col, vec2 uv, vec2 p, float rInner, float rOuter){
                vec2 d = p - uv;
                float l = length(d);
                float r = rOuter - rInner;
                float R = rOuter;

                float x = max(R - l, 0.0);
                float cm = x;
                return brightnessContrast(col, cm * 2.0, cm * 8.0 + 1.0);
            }

            vec3 darken(vec3 col, vec2 uv, vec2 p, float rInner, float rOuter){
                vec2 d = p - uv;
                float l = length(d);
                float r = rInner;
                float R = rOuter;

                float x = max(r - l, 0.0);
                return brightnessContrast(col, -x*10., 1.0);
            }

            #define R0 vec2(0.5, 0.5), 0.1, 0.3

            void main(){
                float warpTransition = clamp(stage, 1.0, 2.0) - 1.0;
                float visionTransition = clamp(stage, 0.0, 1.0);

                vec2 uv = mapCoord(vTextureCoord);
                vec2 uv0 = uv;

                vec2 delta = vec2(0.0);
                delta += warpAround(uv, R0);
                uv += delta * warpTransition;

                uv -= delta * (1.0 - visionTransition);

                vec3 col = texture2D(uSampler, unmapCoord(uv)).rgb;
                vec3 e = vec3(0.0);

                // brightness / contrast
                /*
                e = col;
                // e = enhance(e, uv, R1);
                // e = enhance(e, uv, R2);
                e = enhance(e, uv, vec2(0.7, 0.5), 0.02, 0.1);
                col = mix(e, col, transition);
                */

                // simulate vision
                e = col;
                e = darken(e, uv0, R0);
                col = mix(e, col, 0.0);

                gl_FragColor = vec4(col, 1.0);
            }
        `;
    let visionMapFilter = new VisionMapFilter();

    //Create the renderer
    var stage = new PIXI.Container(),
        renderer = PIXI.autoDetectRenderer(0, 0);
    document.body.appendChild(renderer.view);

    renderer.view.style.position = "absolute";
    renderer.view.style.display = "block";
    renderer.autoResize = true;
    renderer.resize(window.innerWidth, window.innerHeight);

    //Use Pixi's built-in `loader` object to load an image
//    PIXI.loader
//            .add("img_fjords.jpg")
//            .load(setup);

    //This `setup` function will run when the image has loaded

    const webcam = new Webcam();
    webcam.onReady.add(onWebcam);
    webcam.init();

    function setup() {

//        //Create the `cat` sprite from the texture
//        var cat = new PIXI.Sprite(
//            PIXI.loader.resources["img_fjords.jpg"].texture
//        );
//
//        //Add the cat to the stage
//        stage.addChild(cat);

        //Render the stage
        renderer.render(stage);
    }

    let texture;
    let sprite;

    function onWebcam() {
        console.log('webcam loaded');
        console.log(webcam.video);
        texture = new PIXI.Texture.fromVideo(webcam.video);
        sprite = new PIXI.Sprite(texture);

        sprite.x = 0;
        sprite.y = 0;
        sprite.height = renderer.height;
        sprite.width = renderer.width/2;
        sprite.filters = [visionMapFilter, new BarrelFilter(1.2)];

        stage.addChild(sprite);

        sprite = new PIXI.Sprite(texture);

        sprite.x = renderer.width/2;
        sprite.y = 0;
        sprite.height = renderer.height;
        sprite.width = renderer.width/2;
        sprite.filters = [visionMapFilter,new BarrelFilter(1.2)];

        stage.addChild(sprite);


        renderer.render(stage);

        loop();

//        requestAnimationFrame(loop);

    }

    function loop() {
        setTimeout(loop, 70);

        sprite.texture.update();
        renderer.render(stage);
    }

    var transitionId = null;
    var mode = 0;
    var nModes = 3;
    function pointerUp(){
        window.cancelAnimationFrame(transitionId);
        var start = visionMapFilter.uniforms.stage;
        mode = (mode + 1) % (nModes + 1);
        var end = mode;
        transitionId = Math.animation(start, end, 200, Tween.Quad.easeIn, (x)=>{visionMapFilter.uniforms.stage = x});
    }

    stage.interactive = true; 
    stage.on('tap', pointerUp);
    stage.on('click', pointerUp);

    setup();
</script>
</body>
</html>